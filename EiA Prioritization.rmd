---
title: "EiA GCF Prioritization"
author: "Peter Steward, Todd Rosenstock, Ani Ghosh"
date: "09/06/2022"
output: html_document
runtime: shiny
---
  
<style type="text/css">
.main-container {
max-width: 2400px;
margin-left: auto;
margin-right: auto;
}
</style>

```{r setup, include=FALSE}
# ***!!!IMPORTANT!!!*** YOU NEED TO CHANGE THE LINE BELOW TO BE THE PATH WHERE YOU HAVE SAVED THIS PROJECT TO (USE "/" NOT "\")
knitr::opts_knit$set(root.dir = "D:/eia_TZ_climate_tool")
# knitr::opts_knit$set(root.dir = "INSERT FULL FILE PATH HERE")
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```

```{r Load packages,echo=F,message=F,warning=F}

if(!require("pacman", character.only = TRUE)){install.packages("pacman",dependencies = T)}

required.packages <- c("countrycode",
                       "data.table",
                       "devtools",
                       "DT",
                       "MetBrewer",
                       "mgsub",
                       "miceadds",
                       "rgdal",
                       "stringr",
                       "terra",
                       "viridis",
                       "wesanderson"
                       )

pacman::p_load(char=required.packages,install = T,character.only = T)
```
## EiA Climate Prioritization Tool {.tabset .tabset-fade .tabset-pills}
```{r Choose country,echo=F}
country_zips<-data.table(filepath=list.files("Data",".zip",full.names = T))
country_zips [,iso3c:=gsub(".zip|Data/","",country_zips$filepath)]

country_zips[,Country:=countrycode::countrycode(iso3c, origin = 'iso3c', destination = 'country.name')]

selectInput(inputId="country_choice", 
              label=NULL,
              choices = country_zips$Country,
              selected = "Tanzania",
              multiple = F, 
              width="240px")

country_dir<-reactive({
  paste0("Data/", country_zips[Country==input$country_choice,iso3c])
  })

reactive({
  if(!dir.exists(country_dir())){
    dir.create(country_dir())
    unzip(zipfile=country_zips[Country==input$country_choice,filepath],exdir=country_dir(),junkpaths=T)
  }
})

SaveDir<-reactive({
  paste0(country_dir(),"/Analysis")
  })

reactive({
  if(!dir.exists(SaveDir())){
    dir.create(SaveDir())
  }
})

```


```{r Hazards - load meta data and class breaks,echo=F}
hazards<-c("NDD","NTx40","HSM_NTx35","HSH_max","THI_max","NDWS","TAI","NDWL0")
haz_meta<-data.table::fread("./Data/atlas_hazards/metadata.csv")
haz_class<-fread("./Data/atlas_hazards/classes.csv")
haz_classes<-unique(haz_class$description)

Scenarios<-c("ssp245","ssp585")
Times<-c("2021_2040","2041_2060")
Scenarios<-rbind(data.table(Scenario="historic",Time="historic"),data.table(expand.grid(Scenario=Scenarios,Time=Times)))
```

**Define hazard thresholds**  
See https://github.com/AdaptationAtlas/hazards for how hazards layers were created.

**HSH_max** = `r haz_meta[grepl("HSH_max",file.filename),dataset.desc]`  
**HSM_NTx35** = `r haz_meta[grepl("HSM_NTx35",file.filename),dataset.desc]`  
**NDD** = `r haz_meta[grepl("NDD",file.filename),dataset.desc]`  
**NDWL0** = `r haz_meta[grepl("NDWL0",file.filename),dataset.desc]`  
**NDWS** = `r haz_meta[grepl("NDWS",file.filename),dataset.desc]`  
**NTx40** = `r haz_meta[grepl("NTx40",file.filename),dataset.desc]`  
**TAI** = `r haz_meta[grepl("TAI",file.filename),dataset.desc]`  
**THI_max** = `r haz_meta[grepl("THI_max",file.filename),dataset.desc]`  
  
Use the table below set hazard thresholds and the direction of classification (`<` lower or '>' higher than the threshold), and the bottom row to rename the hazard. Note renaming hazards requires recalculation of combined hazards and therefore takes time. When renaming variables **DO NOT** use underscores `_` or the reserved words `mean`,`meanclass`,`prop`,`propclass`,`exceedmean`, `exceedmax`.  

:::: {style="display: flex;"}
::: {}
```{r Hazards - 1 Cat,echo=F}
  selectInput(inputId="H1_cat",
             label=haz_meta[grepl(hazards[1],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 2 Cat,echo=F}
selectInput(inputId="H2_cat",
            label=haz_meta[grepl(hazards[2],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 3 Cat,echo=F}
selectInput(inputId="H3_cat",
            label=haz_meta[grepl(hazards[3],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 4 Cat,echo=F}
selectInput(inputId="H4_cat",
             label=haz_meta[grepl(hazards[4],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 5 Cat,echo=F}
selectInput(inputId="H5_cat",
             label=haz_meta[grepl(hazards[5],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 6 Cat,echo=F}
selectInput(inputId="H6_cat",
             label=haz_meta[grepl(hazards[6],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
:::{}
```{r Hazards - 7 Cat,echo=F}
selectInput(inputId="H7_cat",
             label=haz_meta[grepl(hazards[7],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )  
```
:::
:::{}
```{r Hazards - 8 Cat,echo=F}
selectInput(inputId="H8_cat",
             label=haz_meta[grepl(hazards[8],file.filename),dataset.title_short],
             choices=haz_classes,
             selected="Severe",
             width="140px"
             )
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Hazard Thresholds 1,echo=F}
renderUI({
numericInput(inputId="H1_Thresh", 
               label=NULL,
               value=haz_class[index_name==gsub("_max","",hazards[1]) & description==input$H1_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 2,echo=F}
renderUI({
numericInput(inputId="H2_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[2]) & description==input$H2_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 3,echo=F}    
renderUI({
numericInput(inputId="H3_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[3]) & description==input$H3_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 4,echo=F}  
renderUI({
numericInput(inputId="H4_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[4]) & description==input$H4_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 5,echo=F}    
renderUI({
numericInput(inputId="H5_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[5]) & description==input$H5_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 6,echo=F}   
renderUI({
numericInput(inputId="H6_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[6]) & description==input$H6_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 7,echo=F}      
renderUI({
numericInput(inputId="H7_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[7]) & description==input$H7_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
:::{}
```{r Hazard Thresholds 8,echo=F}  
renderUI({
numericInput(inputId="H8_Thresh", 
               label=NULL, 
               value=haz_class[index_name==gsub("_max","",hazards[8]) & description==input$H8_cat,lower_lim],
               min=0,
               max=100,
               step=1,
               width="140px")
})
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Hazard Directions 1,echo=F}
selectInput(inputId="H1_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 2,echo=F}
selectInput(inputId="H2_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 3,echo=F}
selectInput(inputId="H3_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 4,echo=F}
selectInput(inputId="H4_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 5,echo=F}
selectInput(inputId="H5_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 6,echo=F} 
selectInput(inputId="H6_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 7,echo=F} 
selectInput(inputId="H7_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Hazard Directions 8,echo=F}  
selectInput(inputId="H8_Direction", 
              label=NULL,
              choices = c("<",">"),
              selected = ">",
              multiple = F, 
              width="140px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Hazard names 1,echo=F}
textInput(inputId="H1_Name", 
              label=NULL,
              value = hazards[1],
              width="140px")
```
:::
:::{}
```{r Hazard names 2,echo=F}
textInput(inputId="H2_Name", 
              label=NULL,
              value = hazards[2],
              width="140px")
```
:::
:::{}
```{r Hazard names 3,echo=F}
textInput(inputId="H3_Name", 
              label=NULL,
              value = hazards[3],
              width="140px")
```
:::
:::{}
```{r Hazard names 4,echo=F}
textInput(inputId="H4_Name", 
              label=NULL,
              value = hazards[4],
              width="140px")
```
:::
:::{}
```{r Hazard names 5,echo=F}
textInput(inputId="H5_Name", 
              label=NULL,
              value = hazards[5],
              width="140px")
```
:::
:::{}
```{r Hazard names 6,echo=F} 
textInput(inputId="H6_Name", 
              label=NULL,
              value = hazards[6],
              width="140px")
```
:::
:::{}
```{r Hazard names 7,echo=F} 
textInput(inputId="H7_Name", 
              label=NULL,
              value = hazards[7],
              width="140px")
```
:::
:::{}
```{r Hazard names 8,echo=F}  
textInput(inputId="H8_Name", 
              label=NULL,
              value = hazards[8],
              width="140px")
```
:::
::::

*Note all hazards are calculated for the maize growing season.* 

Here you can subset the climate hazards used in the analysis. We recommend no more than 3 or 4 hazards are included otherwise the combinations of multiple hazards become too numerous to visualize (see `Analysis: Combined hazards` tab).
```{r Hazard - Variables,echo=F}
haz_names<-reactive({
  c(input$H1_Name,input$H2_Name,input$H3_Name,input$H4_Name,input$H5_Name,input$H6_Name,input$H7_Name,input$H8_Name)
  })

renderUI({
  checkboxGroupInput(inputId="Analysis_Vars", 
              label="Hazards to include in analysis",
              choices = haz_names(),
              selected = haz_names()[c(1,3,4)],
              inline=T)
})
```

The `Reccurence threshold` is used when classifying hazards based on the proportions of seasons a hazard is present in a time series of data. If set to 0.5 then a hazard is considered present if it is present in more than 50% of seasons. 

:::: {style="display: flex;"}
::: {}
```{r Hazard Thresholds PropThreshold,echo=F}
numericInput(inputId="PropThreshold",
           label="Recurrence threshold", 
           value=0.5,
           min=0,
           max=0.1,
           step=1,
           width="200px")
```
:::
:::{}

```{r Future -  Choose scenario, echo=F}
  selectInput(inputId="Future", 
              label="Choose future scenario",
              choices =  paste0(Scenarios$Scenario[-1],"-",Scenarios$Time),
              selected =  paste0(Scenarios$Scenario[-1],"-",Scenarios$Time),
              multiple = F, 
              width="180px")

```
:::
::::

*Historical = 1995 to 2013. Note, future scenarios are a multi-model ensemble mean of five models: ACCESS-ESM1-5, MPI-ESM1-2-HR, EC-Earth3, INM-CM5-0, MRI-ESM2-0*

### Data
Load admin areas:
```{r Dataset - load regions}
Geographies<-reactive({
  terra::aggregate(terra::vect(grep("_2.shp",list.files(country_dir(),full.names = T),value = T)),by="NAME_2")
})

# Which units are lakes?
#Geographies$NAME_2[grep("Lake ",Geographies$NAME_2)]

renderPlot({terra::plot(Geographies())})
```
Load cropland extent data (source: https://glad.umd.edu/dataset/croplands)
```{r Dataset - Load global crop land extent}
Cropland1<-reactive({
  terra::crop(terra::mask(terra::rast("Data/Global_cropland_3km_2019.tif"),Geographies()),Geographies())
})

# Convert % to km2
CroplandSize<-reactive({terra::cellSize(Cropland1(),unit="km")})

Cropland<-reactive({
  X<-(Cropland1()/100)*CroplandSize()
  names(X)<-"Cropland_Area"
  X
  })
renderPlot({terra::plot(Cropland())})
```

Load human population data:
```{r Dataset - Load population}
TotalPop<-reactive({
  X<-terra::crop(terra::mask(terra::rast("Data/cell5m_ruralpop_2020_v3.tif"),Geographies()),Geographies())
  names(X)<-"TotalPop"
  X
})

renderPlot({terra::plot(TotalPop())})
```
Load mapSPAM data:
```{r Dataset - mapSPAM}

spam_files<-c("vop_total","production","harvested_area")

SPAM<-reactive({
  SPAM<-terra::rast(grep(paste0(spam_files,collapse="|"),list.files(country_dir(),".tif",full.names = T),value=T))
  names(SPAM)<-paste0(names(SPAM),"-",rep(gsub(".tif","",grep("tif",unlist(tstrsplit(sources(SPAM),"/")),value=T)),each=terra::nlyr(SPAM)/length(spam_files)))
  SPAM
  })

renderPlot({terra::plot(SPAM())})

```
Process MapSPAM data:
```{r Analysis - Process MapSPAM,eval=T}
ms_codes<-data.table::fread("Data/SpamCodes.csv")

# This chunk creates tables that rank crops according to their MapSPAM area within regions. It is not currently used in this script but is useful when select which crops to display in waffle plots

reactive({
  if(!dir.exists(paste0(country_dir(),"/mapspam"))){
    dir.create(paste0(country_dir(),"/mapspam"))
  }
})


ms_dirs<-reactive({
  c(paste0(country_dir(),"/mapspam/SPAMareas1.csv"),paste0(country_dir(),"/mapspam/SPAMareas2.csv"))
})

reactive({
  if(!file.exists(ms_dirs()[1])){
  
  # Run SPAMbyRegion.R to generate the file below
  MinArea<-100 #ha
  # Read in summary of crop areas by region, remove crops with small areas
   
  GeogRast<-terra::rasterize(Geographies(),SPAM(),field="NAME_2")
  
  SPAMareas2<-data.table(terra::zonal(SPAM(),GeogRast,"sum",na.rm=T))
  SPAMareas2<-data.table::melt(SPAMareas2,id.vars = "NAME_2",variable.name = "Crop",value.name = "Area")
  SPAMareas2<-merge(SPAMareas2,data.table(values(Geographies()))[,list(NAME_1,NAME_2)],by="NAME_2",all.x=T)
  
  setnames(SPAMareas2,c("NAME_2","NAME_1"),c("Admin2","Admin1"))
  
  SPAMareas1<-SPAMareas2[order(Admin2,Area,decreasing = T)
                 ][,Rank:=1:.N,by=Admin2
                   ][Area==0|is.na(Area),Rank:=NA
                     ][,Label:=paste(c(Admin2,Crop,Rank),collapse = "-"),by=list(Admin2,Crop,Rank)]
  
  SPAMareas1<-SPAMareas1[,list(Area=sum(Area,na.rm = T)),by=list(Admin1,Crop)
                  ][order(Admin1,Area,decreasing = T)
                    ][,Rank:=1:.N,by=Admin1
                      ][Area==0|is.na(Area),Rank:=NA
                        ][,Label:=paste(c(Admin1,Crop,Rank),collapse = "-"),by=list(Admin1,Crop,Rank)]
  
SPAMareas1[,Variable:=unlist(tstrsplit(Crop,"-",keep=2))
           ][,Crop:=unlist(tstrsplit(Crop,"-",keep=1))
             ][Variable=="production",Unit:="kg"
               ][Variable=="harvested_area",Unit:="ha"
                 ][Variable=="vop_total",Unit:="I$"]

SPAMareas2[,Variable:=unlist(tstrsplit(Crop,"-",keep=2))
           ][,Crop:=unlist(tstrsplit(Crop,"-",keep=1))
             ][Variable=="production",Unit:="kg"
               ][Variable=="harvested_area",Unit:="ha"
                 ][Variable=="vop_total",Unit:="I$"]
  
  data.table::fwrite(SPAMareas2,file=ms_dirs()[2])
  data.table::fwrite(SPAMareas1,file=ms_dirs()[1])
  
  }
})

SPAMareas2<-reactive({data.table::fread(ms_dirs()[1])})
SPAMareas1<-reactive({data.table::fread(ms_dirs()[2])})

```
### View Analysis Code
This section shows the code that powers the hazard classification and data extraction. It is currently undocumented and a general user need not concern themselves with this section.

Create functions to detect and classify hazards:
```{r Analysis - Create functions to classify hazards 1}

ThreshFun<-function(Data,Threshold,Direction){
  if(Direction==">"){
  sum(Data>Threshold)/length(Data)
  }else{
  sum(Data<Threshold)/length(Data)
  }
}

ClassSimple<-function(Data,Threshold,Direction){
  if(Direction==">"){
  as.integer(Data>Threshold)
  }else{
  as.integer(Data<Threshold)
  }
}

Exceedance<-function(Data,Threshold,Direction,Function){
  if(!all(is.na(Data))){
  if(Direction==">"){
    Data<-Data[Data>Threshold]
  }else{
   Data<-Data[Data<Threshold]
  }
    
  if(length(Data)>0){
    Data<-abs(Data-Threshold)
  
  if(Function=="mean"){
    Data<-mean(Data,na.rm=T)
  }
  
  if(Function=="max"){
    Data<-max(Data,na.rm=T)
  }
    }else{
      Data<-0
    }
    
  }else{
    Data<-NA
  }
  return(Data)

}

Infinite2NA<-function(Data){
  Data[is.infinite(Data)]<-NA
  return(Data)
}

ClassifyFun<-function(Data,VAR,Threshold,Direction,PropThreshold,PropTDir){

  Variable<-terra::app(Data,Infinite2NA)
  VarMean<- terra::app(Variable,mean,na.rm=T)
  VarMClass<-VarMean
  VarMClass[]<-as.integer(ClassSimple(Data=VarMClass[],Threshold,Direction))
  VarProp<- terra::app(Variable,ThreshFun,Threshold,Direction)
  VarPClass<-VarProp
  VarPClass[]<-as.integer(ClassSimple(Data=VarPClass[],PropThreshold,PropTDir))
  
  VarExceedMean<-terra::app(Variable,Exceedance,Threshold,Direction,Function="mean")
  VarExceedMax<-terra::app(Variable,Exceedance,Threshold,Direction,Function="max")

  Var<-c(VarMean,VarMClass,VarProp,VarPClass,VarExceedMean,VarExceedMax)
  names(Var)<-paste0(VAR,c("_mean","_meanclass","_prop","_propclass","_exceedmean","_exceedmax"))
  return(Var)
}

ClassifyHazards<-function(Data){
    
    # Generate binary classification of hazards
    X<-sum(terra::rast(lapply(1:terra::nlyr(Data),FUN=function(i){
      X<-Data[[i]]
      X[which(X[]==1)]<-10^(i-1)
      X
    })))
    
    # Translate binary sequence to label
    labels<-names(Data)
    values<-unique(values(X))
    values<-values[!(is.na(values)|is.nan(values))]
    values<-str_pad(values, length(labels), pad = "0")
    
    
    labels_new<-unlist(lapply(values,FUN=function(val){
      val<-stringi::stri_reverse(val)
      pos<-str_locate_all(val,"1")[[1]][,1]
      paste(labels[pos],collapse="+")
    }))
    
    labels<-data.table(values=as.numeric(values),labels=labels_new)[,Nhaz:=0
                                                                    ][labels!="",Nhaz:=1+stringr::str_count(labels,"[+]")
                                                                      ][order(Nhaz,labels)][,N:=0:(.N-1)]
    
    labels[Nhaz==0,labels:="None"][,labels:=gsub("_meanclass|_propclass","",labels)]
    
    # Recode raster to integer values and add labels
    X<-subst(X,labels[,values],labels[,N])
    
    levels(X)<-labels[,list(N,labels)]
    
    Classes<-labels[,list(values,labels,N)]
    colnames(Classes)<-c("Code","Hazard","Recode")
    
    names(X)<-""
    
    X<-list(RastReclass=X,Classes=Classes)
    
    return(X)
}

HazardWrapper<-function(Thresholds,FileName,SaveDir,PropThreshold,PropTDir,hazard_dir,Scenarios){
  Files<-list.files(hazard_dir,".tif",full.names = T)
  Files<-Files[grepl("historical|ENSEMBLE",Files)]
  
  Hazards<-lapply(1:nrow(Scenarios),FUN=function(j){
    for(i in 1:nrow(Thresholds)){
      if(F){
      # Display progress
      cat('\r                                                                                                                     ')
      cat('\r',paste0(i," | ",j))
      flush.console()
      }
      
      save_file<-paste0(SaveDir,"/Haz-",Scenarios$Scenario[j],"-",Scenarios$Time[j],"-",Thresholds[i,Variable],"-",Thresholds[i,Threshold],"-",if(Thresholds[i,Direction]==">"){"G"}else{"L"},".tif")
      
      if(!file.exists(save_file)){

      Data<-terra::rast(Files[grepl(Scenarios$Scenario[j],Files) & grepl(Scenarios$Time[j],Files) & grepl(Thresholds$Variable[i],Files)])
      
      X<-ClassifyFun(Data=Data,
                  VAR=Thresholds[i,Variable],
                  Threshold=Thresholds[i,Threshold],
                  Direction=Thresholds[i,Direction],
                  PropThreshold=PropThreshold,
                  PropTDir=PropTDir)
        terra::writeRaster(X,filename=save_file,overwrite=T)
      }else{
        X<-terra::rast(save_file)
      }
      
      if(i==1){
        Hazards<-X
      }else{
        Hazards<-c(Hazards,X)
      }
    }
    
    Hazards
  })

  Hazards<-lapply(1:length(Hazards),FUN=function(i){
    HAZ<-Hazards[[i]]
    names(HAZ)<-mgsub::mgsub(names(HAZ),Thresholds[,paste0(Variable,"_")],Thresholds[,paste0(Renamed,"_")])
    HAZ
  })
  
  names(Hazards)<-paste0(Scenarios$Scenario,"-",Scenarios$Time)
  
  return(Hazards)
}

HazCombWrapper<-function(Hazards,SaveDir,Scenarios,FileName,SelectedHaz){
  scenario_names<-paste0(Scenarios$Scenario,"-",Scenarios$Time)
# Mean
if(!file.exists(filename=paste0(SaveDir,"/CombMean-",scenario_names[1],"-",FileName,".tif"))){
HazCombMean<-lapply(1:nrow(Scenarios),FUN=function(j){
  
  X<-grep("_meanclass",names(Hazards[[j]]),value=T)
  X<-X[grepl(paste0(SelectedHaz,collapse = "|"),X)]
  
  ClassifyHazards(Data=Hazards[[j]][[X]])
})
names(HazCombMean)<-scenario_names

for(i in 1:length(scenario_names)){
  terra::writeRaster(HazCombMean[[scenario_names[i]]][["RastReclass"]],filename=paste0(SaveDir,"/CombMean-",scenario_names[i],"-",FileName,".tif"),overwrite=T)
  fwrite(HazCombMean[[scenario_names[i]]][["Classes"]],file=paste0(SaveDir,"/CombMean-",scenario_names[i],"-",FileName,".csv"))
}

}else{
  
  HazCombMean<-lapply(scenario_names,FUN=function(scenario_name){
    list(
      RastReclass=terra::rast(paste0(SaveDir,"/CombMean-",scenario_name,"-",FileName,".tif")),
      Classes=data.table::fread(paste0(SaveDir,"/CombMean-",scenario_name,"-",FileName,".csv"))
    )
  })
  
  names(HazCombMean)<-scenario_names
}

# Prop
if(!file.exists(filename=paste0(SaveDir,"/CombProp-",scenario_names[1],"-",FileName,".tif"))){
  HazCombProp<-lapply(1:length(scenario_names),FUN=function(j){
    X<-grep("_propclass",names(Hazards[[j]]),value=T)
    X<-X[grepl(paste0(SelectedHaz,collapse = "|"),X)]
  
    ClassifyHazards(Data=Hazards[[j]][[X]])

  })
  names(HazCombProp)<-scenario_names
  
  for(i in 1:length(scenario_names)){
    terra::writeRaster(HazCombProp[[scenario_names[i]]][["RastReclass"]],filename=paste0(SaveDir,"/CombProp-",scenario_names[i],"-",FileName,".tif"),overwrite=T)
    fwrite(HazCombProp[[scenario_names[i]]][["Classes"]],file=paste0(SaveDir,"/CombProp-",scenario_names[i],"-",FileName,".csv"))
  }

}else{
  
  HazCombProp<-lapply(scenario_names,FUN=function(scenario_name){
    list(
      RastReclass=terra::rast(paste0(SaveDir,"/CombProp-",scenario_name,"-",FileName,".tif")),
      Classes=data.table::fread(paste0(SaveDir,"/CombProp-",scenario_name,"-",FileName,".csv"))
    )
  })
  
  names(HazCombProp)<-scenario_names
}

HazComb<-list(MeanHaz=HazCombMean,PropHaz=HazCombProp)

return(HazComb)
}

#Create a function to intersect the combined hazard layer with MapSPAM data summarized by regions:

ExtractHaz<-function(Regions,Reg.Field,Hazard,HazTab,SPAM,Cropland,TotalPop){
  
  SPAM <- terra::mask(terra::crop(SPAM,Regions),Regions)
  Hazard<-terra::mask(terra::crop(Hazard,Regions),Regions)
  Cropland <- terra::mask(terra::crop(Cropland,Regions),Regions)
  TotalPop<-terra::mask(terra::crop(TotalPop,Regions),Regions)
  
  Hazard<-terra::resample(Hazard,SPAM,method="near")
  TotalPop<-terra::resample(TotalPop,SPAM,method="sum")
  Cropland<-terra::resample(Cropland,SPAM,method="sum")
  
  # Mask human population by cropland
  # TotalPop<-terra::mask(TotalPop,Cropland)
  
  HazardMask<-Hazard
  N<-which(levels(HazardMask)[[1]]=="None")-1
  if(length(N)>0){
    HazardMask[HazardMask==N]<-NA
  }
  MaskedPop<-terra::mask(TotalPop,HazardMask)
  names(MaskedPop)<-"AtRiskPop"

  Regions$Code<-1:length(Regions)*100
  REG<-terra::rasterize(Regions,Hazard,field="Code")
  HAZ<-Hazard+REG
  names(HAZ)<-"Hazard"
  
  X<-data.table(zonal(SPAM,HAZ,fun=sum,na.rm=T))
  X[,Region:=floor(Hazard/100)*100]
  X[,Hazard:=Hazard-Region]
  X[,Region:=terra::values(Regions)[match(X$Region,Regions$Code),Reg.Field]]
  X[,Hazard:=HazTab[match(X$Hazard,Recode),Hazard]]
  X<-data.table::melt(X,id.vars = c("Hazard","Region"),value.name = "Value",variable.name = "Crop")

  Y<-data.table(zonal(c(TotalPop,MaskedPop,Cropland),HAZ,fun=sum,na.rm=T))
  Y[,Region:=floor(Hazard/100)*100]
  Y[,Hazard:=Hazard-Region]
  Y[,Region:=terra::values(Regions)[match(Y$Region,Regions$Code),Reg.Field]]
  Y[,Hazard:=HazTab[match(Y$Hazard,Recode),Hazard]]
  
  REG2<-terra::rasterize(Regions,Hazard,field=Reg.Field)
  Areas<-data.table(zonal(cellSize(REG2,unit="km"),REG2,sum,na.rm=T))
  setnames(Areas,Reg.Field,"Region")
  
  Y<-Y[,list(Cropland.Area=round(sum(Cropland_Area)),
             Pop=round(sum(TotalPop,na.rm=T)),
             PopRisk=round(sum(AtRiskPop,na.rm = T))),by=list(Region,Hazard)]
  
  Y[,Total.Area:=Areas[match(Y$Region,Region),area]]
       
  Y<-Y[,Pop:=sum(Pop),by=Region
       ][,PopRisk:=sum(PopRisk),by=Region
         ][,Cropland.Perc:=round(100*Cropland.Area/Total.Area,2)
           ][!is.na(Hazard)
             ][,Cropland.Area:=NULL
               ][,Crop.Perc:=sum(Cropland.Perc),by=Region
                 ][,PopRiskPerc:=round(100*PopRisk/Pop,2)
                   ][,Pop:=round(Pop/10^6,2)
                     ][,PopRisk:=round(PopRisk/10^6,2)]
  
  Y<-dcast(Y,Region+Total.Area+Crop.Perc+Pop+PopRiskPerc+PopRisk~Hazard,value.var = "Cropland.Perc")[Total.Area!=0]

  return(list(SPAM=X,CropPop=Y))

}

HazXRegionWrapper<-function(SaveDir,FileName,SPAM,Geographies,HazComb,Cropland,TotalPop){
  SaveFile<-paste0(SaveDir,"/Tables-",FileName,".RData")
  if(!file.exists(SaveFile)){
  
  Geog1<-terra::aggregate(Geographies,"NAME_1")

HazXRegion<-lapply(1:length(HazComb),FUN=function(j){
  
  Data<-lapply(1:length(HazComb[[j]]),FUN=function(i){
  HazExt1<-ExtractHaz(Regions=Geog1,
                     Reg.Field="NAME_1",
                     Hazard=HazComb[[j]][[i]]$RastReclass,
                     HazTab=HazComb[[j]][[i]]$Classes,
                     SPAM=SPAM,
                     Cropland=Cropland,
                     TotalPop=TotalPop)
  
  HazExt2<-ExtractHaz(Regions=Geographies,
             Reg.Field="NAME_2",
             Hazard=HazComb[[j]][[i]]$RastReclass,
             HazTab=HazComb[[j]][[i]]$Classes,
             SPAM=SPAM,
             Cropland=Cropland,
             TotalPop=TotalPop)
  
  list(Admin1=HazExt1,Admin2=HazExt2)
})

  names(Data)<-names(HazComb[[j]])
  Data
})

names(HazXRegion)<-names(HazComb)

save(HazXRegion,file=SaveFile)
}else{
  HazXRegion<-miceadds::load.Rdata2(SaveFile)
}
  return(HazXRegion)
}
```
Create table of thresholds and filenames:
```{r Analysis - Create thresholds table and filenames}
Thresholds<-reactive({
  data.table(
  Variable=hazards,
  Renamed=haz_names(),
  Threshold=c(input$H1_Thresh,input$H2_Thresh,input$H3_Thresh,input$H4_Thresh,input$H5_Thresh,input$H6_Thresh,input$H7_Thresh,input$H8_Thresh),
  Direction=c(input$H1_Direction,input$H2_Direction,input$H3_Direction,input$H4_Direction,input$H5_Direction,input$H6_Direction,input$H7_Direction,input$H8_Direction)
)
})

renderPrint({Thresholds()})

FileName<-reactive({
  gsub("<","L",gsub(">","G",paste(unlist(Thresholds()[,!"Renamed"]),collapse="")))
})

FileName2<-reactive({
  gsub("<","L",gsub(">","G",paste(unlist(Thresholds()[Renamed %in% input$Analysis_Vars,!"Renamed"]),collapse="")))
})

renderPrint({FileName2()})

```
Detect and classify hazards:
```{r Analysis - Classify hazards}


Hazards<-reactive({
  HazardWrapper(Thresholds=Thresholds(),
                FileName=FileName(),
                SaveDir=SaveDir(),
                PropThreshold=input$PropThreshold,
                PropTDir=">",
                hazard_dir= country_dir(),
                Scenarios=Scenarios)
})

renderPrint({names(Hazards())})
renderPrint({names(Hazards()[[1]])})
```

Combine hazards into a single layer:
```{r Analysis -  Combine hazards}
HazComb<-reactive({
  HazCombWrapper(Hazards=Hazards(),
                 SaveDir=SaveDir(),
                 Scenarios=Scenarios,
                 FileName=FileName2(),
                 SelectedHaz = input$Analysis_Vars)
  })

renderPrint({names(HazComb())})
renderPrint({names(HazComb()[[1]])})
renderPrint({names(HazComb()[[1]][[1]])})
```

Summarize hazards by region and MapSPAM data:
```{r Analysis - Summarize hazards by region and crop}
HazXRegion<-reactive({
  HazXRegionWrapper(SaveDir=SaveDir(),
                    FileName=FileName2(),
                    SPAM=SPAM(),
                    Cropland=Cropland(),
                    TotalPop=TotalPop(),
                    Geographies=Geographies(),
                    HazComb=HazComb())
})

renderPrint({names(HazXRegion())})
```

### Results {.tabset .tabset-fade .tabset-pills}
Here you can select which hazards, scenarios  and geographies to display. If you change the **`Admin level`** from `District` to `State` then results are presented aggregated to state level, but note that any deselected districts will still be subtracted from state level data. Selecting the hazards to display here does not affect the calculation or display of combined hazards.

:::: {style="display: flex;"}
::: {}
```{r Plot - Variables,echo=F}
renderUI({
  checkboxGroupInput(inputId="Plot_Vars", 
              label="Display hazards                        ",
              choices = input$Analysis_Vars,
              selected= input$Analysis_Vars, 
              width=length(input$Analysis_Vars)*80,
              inline=T)
})
```
:::
:::{}
```{r Geography -  Choose admin level, echo=F}
  selectInput(inputId="AdminLevel1", 
              label="Admin level",
              choices = c("Region","District"),
              selected = "District",
              multiple = F, 
              width="140px")

AdminLevel<-reactive({
  if(input$AdminLevel1=="Region"){
    "Admin1"
  }else{
    "Admin2"
  }
})
```
:::
:::{}
```{r Geography - Choose admin1s, echo=F}
  selectInput(inputId="Admin1_Selection", 
              label="Select regions",
              choices = c("All","None",""),
              selected = "All",
              multiple = F, 
              width="140px")


```
:::
:::{}
```{r Geography - Choose states, echo=F}
renderUI({
  checkboxGroupInput(inputId="Admin1", 
                     label="Select regions",
                     choices = sort(unique(Geographies()$NAME_1)),
                     selected = if(input$Admin1_Selection=="All"){
                         sort(unique(Geographies()$NAME_1))
                         }else{
                           if(input$Admin1_Selection=="None"){
                             NULL
                           }
                         },
                     inline=T)
})
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Geography - Choose district 1, echo=F}
conditionalPanel(
  condition = "input.AdminLevel1 == 'District'",
  selectInput(inputId="Selection", 
              label="Select districts",
              choices = c("All","None",""),
              selected = "All",
              multiple = F, 
              width="140px")
)

```
:::
:::{}
```{r Geography - Choose districts 2, echo=F}
conditionalPanel(
 condition = "input.AdminLevel1 == 'District'",
  renderUI({
    checkboxGroupInput(inputId="Admin2", 
                       label="",
                       choices = sort(unique(Geographies()$NAME_2[Geographies()$NAME_1 %in% input$Admin1])),
                       selected = if(input$Selection=="All"){
                         sort(unique(Geographies()$NAME_2[Geographies()$NAME_1 %in% input$Admin1]))
                         }else{
                           if(input$Selection=="None"){
                             NULL
                           }
                         },
                       inline=T)
  })
)


```
:::
::::


**Plotting Parameters** - here you can adjust some plot features such as colour palette, text size, and plot size.

:::: {style="display: flex;"}
:::{}
```{r Plot - Palette,echo=F,eval=T}

Viridis<-data.table(Source="viridis",Palette=c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"))
Met<-data.table(Source="MetBrewer",Palette=names(MetBrewer::MetPalettes))
Wes<-data.table(Source="wesanderson",Palette=names(wesanderson::wes_palettes))

Palettes<-rbind(Viridis,Met)

  selectInput(inputId="Palette", 
              label="Palette",
              choices = Palettes[,sort(Palette)],
              selected="turbo", 
              multiple = F, 
              width="150px")
  
PalFun<-function(PalName,N,Names) {
Viridis<-data.table(Source="viridis",Palette=c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"))
Met<-data.table(Source="MetBrewer",Palette=names(MetBrewer::MetPalettes))
Palettes<-rbind(Viridis,Met)
    
 if(Palettes[Palette==PalName,Source]=="viridis"){
    PAL<-viridis::viridis(N,option=PalName)
 }

if(Palettes[Palette==PalName,Source]=="MetBrewer"){
     PAL<-MetBrewer::met.brewer(name=PalName, n=N, type="continuous")
}

  if(Palettes[Palette==PalName,Source]=="Wes"){
     PAL<-wesanderson::wes_palette(name=PalName, n=N, type="continuous")
  }
names(PAL)<-Names

return(PAL)
}

```
:::
:::{}
```{r Plot - Text Size, echo=F}
numericInput(inputId="TextSize",
             label="Text Size",
             value=1,
             min=1,
             max=5,
             step=0.1,
             width="80px")
```
:::
:::{}
```{r Plot - LegPos,echo=F}
  selectInput(inputId="LegPos", 
              label="Legend position",
              choices = c("bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right","center"),
              selected="bottomleft", 
              multiple = F,
              width="160px")
```
:::
:::{}
```{r Plot - Legend Columns, echo=F}
numericInput(inputId="LegCols",
             label="No. Legend Columns",
             value=1,
             min=1,
             max=5,
             step=1,
             width="140px")
```
:::
:::{}
```{r Plot - Border width , echo=F}
numericInput(inputId="borderwidth",
             label="Border width",
             value=1,
             min=0.1,
             max=5,
             step=0.25,
             width="120px")
```
:::
:::{}
```{r Plot - Base width,echo=F}
  numericInput(inputId="PlotBaseWidth", 
              label="Plot width (px)",
              value = 1200,
              min=100, 
              max=5000,
              step = 100,
              width="150px")
```
:::
:::{}
```{r  Plot - Adjust height, echo=F}
numericInput(inputId="Plot.Height",
             label="Adjust height",
             value=0.5,
             min=0.1,
             max=3,
             step=0.1, 
             width="120px")
```
:::
:::{}
```{r Plot - Adjust width , echo=F}
numericInput(inputId="Plot.Width",
             label="Adjust width",
             value=1,
             min=0.1,
             max=3,
             step=0.1,
             width="120px")
```
:::
::::

```{r Plot - Create bar height and width functions, echo=F}
  Plot.Height <- function(){input$PlotBaseWidth*input$Plot.Height}
  Plot.Width <- function(){input$PlotBaseWidth*input$Plot.Width}
```

```{r Set admin areas for extraction, echo=F}
SubGeog<-reactive({
    if(input$AdminLevel1=="District"){
      Geographies()[Geographies()$NAME_2 %in% input$Admin2,]
    }else{
      Geographies()[Geographies()$NAME_1 %in% input$Admin1,]
    }
})
```

```{r Plot - prepare data for plotting hazards,echo=F}

PlotHazards<-reactive({
  terra::mask(terra::crop(Hazards()[["historic-historic"]],SubGeog()),SubGeog())
})

PlotHazards_future<-reactive({
  terra::mask(terra::crop(Hazards()[[input$Future]],SubGeog()),SubGeog())
})

PlotHazards_diff<-reactive({
 PlotHazards_future()- PlotHazards()
})
```

**Note there is a potential issue when creating palette for combined hazards if different hazards are present in historic vs future**
```{r Plot - prepare data for plotting hazards 2,echo=F}
HazPalCombMean<-reactive({PalFun(PalName=input$Palette,
                      N=nrow(HazComb()[["MeanHaz"]][[input$Future]][["Classes"]]),
                      Names=HazComb()[["MeanHaz"]][[input$Future]][["Classes"]])
})

HazPalCombProp<-reactive({PalFun(PalName=input$Palette,
                      N=nrow(HazComb()[["PropHaz"]][[input$Future]][["Classes"]]),
                      Names=HazComb()[["PropHaz"]][[input$Future]][["Classes"]])
})


addGeog1<-function(){terra::plot(terra::aggregate(SubGeog(),by="NAME_1"),add=T,border="black",lwd=input$borderwidth)}
addGeog2<-function(){terra::plot(SubGeog(),add=T,border="black",lwd=input$borderwidth)}


```

#### Severity and recurrance {.tabset .tabset-fade .tabset-pills}
##### Scenario means
```{r Plot - Means prepare data,echo=F}
SR_plot1_mean<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_mean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_mean")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_mean_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_mean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_mean")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

SR_plot1_class<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_meanclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_meanclass")]]
  rast_names<-c(paste0("historic-",names(historic)),paste0(input$Future,"-",names(future)))
  x<-c(historic,future)
  for(i in 1:nlyr(x)){
  set.cats(x,layer=i,value=data.frame(id=c(0,1),presence=c("absent","present")))
  }
  names(x)<-rast_names
  x
})

SR_plot1_class_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_meanclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_meanclass")]]*10
  rast_names<-names(historic)
  x<-future+historic
  for(i in 1:nlyr(x)){
    set.cats(x,layer=i,value=data.frame(id=c(0,1,10,11),diff=c("neither","past","future","past+future")))
  }
  names(x)<-rast_names
  x
})

```

Mean values of climate variables
```{r Plot - Means,echo=F}
renderPlot({
terra::plot(SR_plot1_mean(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for mean value of climate variables
```{r Plot - Means diff,echo=F}
renderPlot({
terra::plot(SR_plot1_mean_diff(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Scenario means classified according to hazard thresholds
```{r Plot - Meanclass,echo=F}
renderPlot({
terra::plot(SR_plot1_class(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2
)
},height=Plot.Height, width=Plot.Width)
```

Agreement between historic and future scenarios for classified hazards
```{r Plot - Meanclass diff,echo=F}
renderPlot({
terra::plot(SR_plot1_class_diff(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2
)
},height=Plot.Height, width=Plot.Width)
```

##### Recurrence
```{r Plot - prepare Prop,echo=F}
SR_plot1_prop<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_prop")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_prop_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_prop")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

SR_plot1_prop_class<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_propclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_propclass")]]
  rast_names<-c(paste0("historic-",names(historic)),paste0(input$Future,"-",names(future)))
  x<-c(historic,future)
  for(i in 1:nlyr(x)){
  set.cats(x,layer=i,value=data.frame(id=c(0,1),presence=c("absent","present")))
  }
  names(x)<-rast_names
  x
})

SR_plot1_prop_class_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_propclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_propclass")]]*10
  rast_names<-names(historic)
  x<-future+historic
  for(i in 1:nlyr(x)){
    set.cats(x,layer=i,value=data.frame(id=c(0,1,10,11),diff=c("neither","past","future","past+future")))
  }
  names(x)<-rast_names
  x
})

```

Recurrence risk for climate hazards (the proportion of seasons where a hazard is present with all the years of a scenario)
```{r Plot - Prop,echo=F}
renderPlot({
terra::plot(SR_plot1_prop(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for recurrence risk of climate hazards
```{r Plot - Prop diff,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_diff(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

For each hazard if the recurrence risk is greater than the recurrence threshold, `r reactive({input$PropThreshold})`, then a hazard is considered to be present
```{r Plot - Propclass,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_class(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2
)
},height=Plot.Height, width=Plot.Width)
```

Agreement between historic and future scenarios for classified hazards
```{r Plot - Propclass diff,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_class_diff(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2
)
},height=Plot.Height, width=Plot.Width)
```

Recurrence risk for any one hazard being present
```{r Plot -  Prop Class Any Analysis,echo=F}
AnyFun<-function(X){
1-prod(1-X)
}

PlotHazards_any<-reactive({
  x<-terra::app(PlotHazards()[[paste0(input$Plot_Vars,"_prop")]],AnyFun)
  names(x)<-"historic"
  x
})

PlotHazards_future_any<-reactive({
  x<-terra::app(PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]],AnyFun)
  names(x)<-input$Future
  x
  })

PlotHazards_diff_any<-reactive({
 x<-PlotHazards_future_any()- PlotHazards_any()
 names(x)<-"future minus historic"
 x
})


SR_any_plot<-reactive({
  x<-c(PlotHazards_any(),PlotHazards_future_any(),PlotHazards_diff_any)
})

```

```{r Plot - Prop Class Any, echo=F}
renderPlot({
terra::plot(SR_any_plot(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)

```

##### Severity

```{r Plot - Prepare exceedance mean,echo=F}
SR_plot1_exceed_mean<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmean")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_exceed_mean_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmean")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})


SR_plot1_exceed_max<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmax")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmax")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_exceed_max_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmax")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmax")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

```

Hazard severity is the mean exceedance of a hazard threshold value (exceedance = abs(Value-Threshold)). It is calculated from only those seasons where a hazard is present (i.e., the hazard threshold is exceeded).
```{r Plot - Exceed mean,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_mean(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for mean exceedance of climate hazards.
```{r Plot - Exceed mean diff,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_mean_diff(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Hazard severity as the maximum exceedance of a hazard threshold value (exceedance = abs(Value-Threshold)) across all the years within a scenario.
```{r Plot - Exceed max,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_max(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for max exceedance of climate hazards.
```{r Plot - Exceed max diff,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_max_diff(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

##### Severity & recurrence
```{r Table - Severity x Risk function, echo=F}
SxRtabFun<-function(Hazards,Plot_Vars,ExtractBy){
  Hazards<-Hazards[[paste0(rep(Plot_Vars,each=4),c("_prop","_mean","_exceedmean","_exceedmax"))]]
  Data<-data.table(terra::zonal(x=Hazards,z=ExtractBy,fun=mean,na.rm=T))
  colnames(Data)[1]<-"Admin_area"
  Data<-melt(Data,id.vars="Admin_area")
  Data[,Variable:=strsplit(as.character(variable),"_")][,Variable:=unlist(lapply(Variable,FUN=function(x){x[length(x)]}))]
  Data[,Hazard:=gsub(paste(paste0("_",unique(Variable)),collapse="|"),"",variable)][,variable:=NULL]

  Data<-dcast(Data,Admin_area+Hazard~Variable,value.var="value")

  return(Data)
}
```

```{r Create raster versions of admin areas,echo=F}
SubGeog_rast<-reactive({
  if(input$AdminLevel1=="District"){
    rasterize(Geographies(),PlotHazards(),field="NAME_2")
    }else{
      rasterize(Geographies(),PlotHazards(),field="NAME_1")
      }
  })
```

```{r Table - Severity x Risk calculation, echo=F}
SxRtab_hist<-reactive({
  x<-SxRtabFun(Hazards=PlotHazards(),
            Plot_Vars=input$Plot_Vars,
            ExtractBy=SubGeog_rast())
  x[,Scenario:="historic"]
  x<-x[,c(1,7,2,3:6)]
  x
})

SxRtab_future<-reactive({
  x<-SxRtabFun(Hazards=PlotHazards_future(),
            Plot_Vars=input$Plot_Vars,
            ExtractBy=SubGeog_rast())
  x[,Scenario:=input$Future]
  x<-x[,c(1,7,2,3:6)]
  x
})

SxRtab_diff<-reactive(({
  x<-data.table(SxRtab_future()[,1:3],SxRtab_future()[,4:7]-SxRtab_hist()[,4:7])
  x[,Scenario:="difference"]
  x
}))


SxRtab<-reactive({
  rbind(SxRtab_hist(),SxRtab_future(),SxRtab_diff())
})
```

This table presents the intersection of hazard severity and recurrence for the selected geographic area. The `mean` column is the average value of the climate variable. Severity is represented by the mean  and max exceedance of hazard threshold (`exceedmean` and `exceedmax` columns). Recurrence is represented by the proportion of years containing a hazard (`prop` column). Variables are averaged across all the values within an area.
```{r Table - Severity x Risk DT, echo=F}
renderDT({
  datatable(dplyr::mutate_if(SxRtab(),is.numeric,~round(.,3)),
            caption="Hazard recurrance x severity (means by geography)",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```

#### Combined hazards
```{r Plot - Prepare combinations mean,echo=F}
CombPlot_historic<-reactive({ 
   X<-terra::mask(
     terra::crop(x = HazComb()[["MeanHaz"]][["historic-historic"]][["RastReclass"]], SubGeog()),
     SubGeog())
      X<-droplevels(X)
      X
  })

CombPlot_future<-reactive({ 
  X<-terra::mask(
      terra::crop(x = HazComb()[["MeanHaz"]][[input$Future]][["RastReclass"]], SubGeog()),
      SubGeog())
  X<-droplevels(X)
  X
  })

CombPlot_agree_mean<-reactive({
  x<-CombPlot_historic()==CombPlot_future()
  levels(x)<-data.frame(c(T,F),c("no change","change"))
  x
})


CombPlot<-reactive({
  x<-c(CombPlot_historic(),CombPlot_future()) 
  names(x)<-c("historic",input$Future)
  x
})
```

```{r Plot - Plot combinations mean check levels match,echo=F}
renderPrint({
  if(all(levels(CombPlot_historic()[,2]==levels(CombPlot_future()[,2])))){
    "All hazard combinations match"
  }else{
     "Hazard combinations differ"
      CombPlot_historic()[,2]
      CombPlot_future()[,2]
  }
})
```

This plot shows the intersection of climate hazards classified using scenario means (average of all years).
```{r Plot - Plot combinations mean,echo=F}
renderPlot({
terra::plot(CombPlot(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=nrow(levels(CombPlot())[[1]]),
                      Names=levels(CombPlot()))
)
},height=Plot.Height, width=Plot.Width)

```

```{r Plot - Prepare combinations prop,echo=F}
CombPlotProp_historic<-reactive({ 
  X<-terra::mask(
    terra::crop(x = HazComb()[["PropHaz"]][["historic-historic"]][["RastReclass"]], SubGeog()),
    SubGeog())
  X<-droplevels(X)
  X
  })

CombPlotProp_future<-reactive({ 
  X<-terra::mask(
    terra::crop(x = HazComb()[["PropHaz"]][[input$Future]][["RastReclass"]], SubGeog()),
    SubGeog())
    X<-droplevels(X)
    X
    })

renderPrint({
  if(all(levels(CombPlotProp_historic()[,2]==levels(CombPlotProp_future()[,2])))){
    "All hazard combinations match"
  }else{
     "Hazard combinations differ"
      CombPlotProp_historic()[,2]
      CombPlotProp_future()[,2]
  }
})

CombPlot_agree_prop<-reactive({
  x<-CombPlotProp_historic()==CombPlotProp_future()
  levels(x)<-data.frame(c(T,F),c("no change","change"))
  x
})

CombPlotProp<-reactive({
  x<-c(CombPlotProp_historic(),CombPlotProp_future()) 
  names(x)<-c("historic",input$Future)
  x
})

```

This plot shows the intersection of climate hazards classified using the recurrence risk threshold.
```{r Plot - Plot combinations prop,echo=F}
renderPlot({
terra::plot(CombPlotProp(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=nrow(levels(CombPlotProp())[[1]]),
                      Names=levels(CombPlotProp()))
)
},height=Plot.Height, width=Plot.Width)
```

This plot shows the agreement between historic and future hazards for the two different calculation methods (left is mean and right is recurrence risk)
```{r Plot - Plot agreement,echo=F}

CombPlot_agree<-reactive({
  x<-c(CombPlot_agree_mean(),CombPlot_agree_prop()) 
  names(x)<-c("agreement (scenario means)","agreement (recurrence risk)")
  x
})

renderPlot({
terra::plot(c(CombPlot_agree()),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols)
)
},height=Plot.Height, width=Plot.Width)
```

#### Risk x Exposure {.tabset .tabset-fade .tabset-pills}
This section takes the combined hazards and intersects them with spatial datasets that represent exposure, namely human rural population and the harvested area of different crops (source:MapSPAM). You can choose the shareholding method which determines the combined hazards layer used for intersection. *It is possible to choose other MapSPAM crop statistics such as total production or value of production, but this functionality is not yet implemented*.

```{r Table -  Method, echo=F}
selectInput(inputId="HazMeth1",
             label="Thresholding method", 
            choices = c("Scenario mean","Recurrence"),
            selected = "Scenario mean",
            multiple = F, 
            width="150px")

HazMeth<-reactive({
  if(input$HazMeth1=="Recurrence"){
    "PropHaz"
  }else{
    "MeanHaz"
  }
})
```

```{r Table - create summary function,echo=F}
PrepTable<-function(Data,Method,Scenario,AdminLevel,Geographies,A1,A2,Table){
  Data<-Data[[Method]][[Scenario]][[AdminLevel]][[Table]]
  if(AdminLevel=="Admin2"){
    setnames(Data,"Region","Admin2",skip_absent=T)
    Geog<-unique(data.table(terra::values(Geographies))[,list(NAME_1,NAME_2)])
    names(Geog)<-c("Admin1","Admin2")
    Data[,Admin1:=Geog[match(Data$Admin2,Admin2),Admin1]]
    Data<-Data[Admin2 %in% A2]
  }else{
    setnames(Data,"Region","Admin1",skip_absent=T)
    Data<-Data[Admin1 %in% A1]
    if("Hazard" %in% colnames(Data)){
      Data<-Data[,list(Value=sum(Value,na.rm=T)),by=list(Admin1,Crop,Hazard)]
    }
  }
  
  Data
  
}
```

##### Cropland exposure
This table shows the percentage of a geographic area that is exposed to different hazards and hazard combinations. The table presents the total area in km2 of a geography (`Total.Area`), the percentage of the area that is cropland (`Crop.Perc` column), the human rural population in millions within this cropland area (`Pop` column), the human population in millions and as a percentage exposed to any hazard (`Pop.Risk` and `Pop.Perc` columns), and the percentage of the total area that is exposed to specific hazards (columns named with hazards). Note hazards are masked to cropland extent and sum to percentage of the area that is cropland.
```{r Analysis - Subset data PopCrop,echo=F}
DT_Data_historic<-reactive({
  PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario="historic-historic",
                   AdminLevel=AdminLevel(),
                   Geographies=Geographies(),
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="CropPop")[,Scenario:="historic"]
})

DT_Data_future<-reactive({
  PrepTable(Data=HazXRegion(),
             Method=HazMeth(),
             Scenario=input$Future,
             AdminLevel=AdminLevel(),
             Geographies=Geographies(),
             A1=input$Admin1,
             A2=input$Admin2,
             Table="CropPop")[,Scenario:=input$Future]
})

DT_diff_fun<-function(historic,future){
  classes<-sapply(historic,class)
  cols_in<-names(classes)[classes %in% c("numeric","integer")]
  cols_out<-names(classes)[!classes %in% c("numeric","integer")]
  cols_out<-cols_out[cols_out!="Scenario"]
  x<-future[,..cols_in]-historic[,..cols_in]
  x[,Scenario:="difference"]
  x<-c(historic[,..cols_out],x)
  return(x)
}

DT_Data_diff<-reactive({
  DT_diff_fun(historic=DT_Data_historic(),future=DT_Data_future())
})

DT_Data<-reactive({
  data.table::rbindlist(list(DT_Data_historic(),DT_Data_future(),DT_Data_diff()),use.names=T)
})

```

```{r Analysis - Display DT PopCrop,echo=F}
renderDT({
  datatable(DT_Data()[,Total.Area:=round(Total.Area,3)],
            caption="Cropland hazards by geography",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```

##### Hazard x crop x geography

**Tables**  
For each geography this table shows the mapSPAM value of production of a crop (international USD) that is exposed to a hazard or combination of hazards.
```{r Table - SPAM subset data,echo=F}
DT_Data2_historic<-reactive({
  X<-PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario="historic-historic",
                   AdminLevel=AdminLevel(),
                   Geographies=Geographies(),
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="SPAM")[,Value:=round(Value,1)
                                 ][,Scenario:="historic"]
})

DT_Data2_future<-reactive({
  X<-PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario=input$Future,
                   AdminLevel=AdminLevel(),
                   Geographies=Geographies(),
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="SPAM")[,Value:=round(Value,1)
                                 ][,Scenario:=input$Future]
})

DT2_diff_fun<-function(historic,future){
  classes<-sapply(historic,class)
  cols_in<-names(classes)[classes %in% c("numeric","integer")]
  cols_out<-names(classes)[!classes %in% c("numeric","integer")]
  cols_out<-cols_out[cols_out!="Scenario"]
  merged<-merge(future[,!"Scenario"],historic[,!"Scenario"],by=cols_out,all.x=T)
  colnames(merged)[(ncol(merged)-1):ncol(merged)]<-c("future","historic")
  merged[,difference:=future-historic]
  setnames(merged,"future",future$Scenario[1])
  
  if("Admin2" %in% cols_out){
    merged<-melt(merged,id.vars=c("Admin1","Admin2","Crop","Hazard"),variable.name = "Scenario",value.name = "Value")
  }else{
    merged<-melt(merged,id.vars=c("Admin1","Crop","Hazard"),variable.name = "Scenario",value.name = "Value")
  }
  
  return(merged)
}


DT_Data2<-reactive({
  X<-DT2_diff_fun(historic=DT_Data2_historic(),future=DT_Data2_future())[,Variable:=unlist(tstrsplit(Crop,"-",keep=2))
                                                                      ][,Crop:=unlist(tstrsplit(Crop,"-",keep=1))
                                                                        ][Variable=="production",Unit:="kg"
                                                                          ][Variable=="harvested_area",Unit:="ha"
                                                                            ][Variable=="vop_total",Unit:="I$"]
  
  X<-X[,Crop:=ms_codes$Fullname[match(trimws(tolower(X$Crop)),ms_codes$Code)]]
  X
})
```

```{r Table - SPAM subset render DT,echo=F}
renderDT({
  datatable(DT_Data2(),
            caption="Crop VoP exposed to hazards",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```

:::: {style="display: flex;"}
:::{}
```{r Table - SPAM Make wide,echo=F}
  selectInput(inputId="MakeWide", 
              label="Make table wide?",
              choices = c("Yes", "No"),
              selected="Yes", 
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Table -  Min Area, echo=F}
numericInput(inputId="MinVoP",
             label="Min VoP (Int$)", 
             value=1,
             min=0,
             max=100000,
             step=50,
             width="200px") 
```
:::
::::

```{r Table - SPAM display DT,echo=F}
renderDT({
  datatable(if(input$MakeWide=="Yes"){
    if(AdminLevel()=="Admin2"){
      dcast(DT_Data2()[Variable=="vop_total"][Value>input$MinVoP,Value:=round(Value,1)],Admin1+Admin2+Scenario+Crop+Variable+Unit~Hazard,value.var="Value")
    }else{
      dcast(DT_Data2()[Variable=="vop_total"][Value>input$MinVoP,Value:=round(Value,1)],Admin1+Scenario+Crop+Variable+Unit~Hazard,value.var="Value") 
    }
    }else{
      DT_Data2()[Variable=="vop_total"][Value>input$MinVoP,Value:=round(Value,1)]},
            caption="Cropland hazards by geography",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) 
  
})

```

**Maps**

:::: {style="display: flex;"}
:::{}
```{r Plot - Choose SPAM variable,echo=F}
  selectInput(inputId="spam_variable", 
              label="Choose spam variable to display",
              choices = spam_files,
              selected=spam_files[1], 
              multiple = F, 
              width="280px")

SPAM_plot<-reactive({
  X<-terra::mask(terra::crop(SPAM(),SubGeog()),SubGeog())
  X<-X[[grepl(input$spam_variable,names(X))]]
  names(X)<-tolower(unlist(tstrsplit(names(X),"-",keep=1)))
  names(X)<-ms_codes[match(names(X),Code),Fullname]
  X
  })

Vals<-reactive({
  Vals<-unlist(lapply(1:nlyr(SPAM_plot()),FUN=function(i){sum(SPAM_plot()[[i]][],na.rm=T)}))
  names(Vals)<-names(SPAM_plot())
  Vals<-sort(Vals,decreasing=T)
})


```
:::
:::{}
```{r Plot - Choose SPAM Crops,echo=F}
renderUI({
  checkboxGroupInput(inputId="spam_crops", 
              label="Crops to include in plot",
              choices = names(Vals()),
              selected = names(Vals())[1:9],
              inline=T)
})


SPAM_plot2<-reactive({
  SPAM_plot()[[grep(paste(input$spam_crops,collapse="|"),names(SPAM_plot()))]]
})
```
:::
::::

```{r Plot - MAPspam,echo=F}
renderPlot({
terra::plot(SPAM_plot2(),
            fun=if(input$AdminLevel1=="District"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols))

},height=Plot.Height, width=Plot.Width)

```